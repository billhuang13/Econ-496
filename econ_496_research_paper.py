# -*- coding: utf-8 -*-
"""Econ 496 research paper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qgszBfabpgaxElvu1nNe8jhVmNghT2rf
"""

pip install pycoingecko

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import mean_squared_error
from scipy import stats
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from itertools import product
from collections import defaultdict
from statsmodels.tsa.stattools import adfuller
import statsmodels.api as sm
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression

from pycoingecko import CoinGeckoAPI
import pandas as pd
import requests
import json
cg = CoinGeckoAPI()

url = "https://api.coingecko.com/api/v3/coins/list?include_platform=true&x_cg_api_key=CG-MW2GUotXN1v7GqXTiCLgQBqU"
headers = {"accept": "application/json"}
response = requests.get(url, headers=headers)

coin_df = pd.DataFrame(json.loads(response.text))

coin_df

"""## Data Extraction and Exploration

#### Crypto data
"""

coin_df[coin_df['name'] == 'USDC']
# Listing the name and their ids so we can extract the prices using id
# 1. Bitcoin: bitcoin
# 2. Ethereum: ethereum
# 3. Tether: tether
# 4. BNB: binancecoin
# 5. Solana: solana
# 6. USDC: usd-coin
# 7. XRP: ripple
# 8. Dogecoin: dogecoin
# 9. Toncoin: the-open-network
# 10. Cardano: cardano

# These are the top 10 cryptocurrencies in terms of the market cap

# Bitcoin
ohlc = cg.get_coin_ohlc_by_id(id="bitcoin", vs_currency="usd", days="365")
btc = pd.DataFrame(ohlc)
btc.columns = ["date", "open", "high", "low", "close"]
btc["date"] = pd.to_datetime(btc["date"], unit="ms")

btc.head(3)

# ETH
ohlc = cg.get_coin_ohlc_by_id(id="ethereum", vs_currency="usd", days="365")
eth = pd.DataFrame(ohlc)
eth.columns = ["date", "open", "high", "low", "close"]
eth["date"] = pd.to_datetime(eth["date"], unit="ms")

eth.head(3)

# 3. Tether: tether
ohlc = cg.get_coin_ohlc_by_id(id="tether", vs_currency="usd", days="365")
tether = pd.DataFrame(ohlc)
tether.columns = ["date", "open", "high", "low", "close"]
tether["date"] = pd.to_datetime(tether["date"], unit="ms")

tether.head(3)

# 4. BNB: binancecoin
ohlc = cg.get_coin_ohlc_by_id(id="binancecoin", vs_currency="usd", days="365")
bnb = pd.DataFrame(ohlc)
bnb.columns = ["date", "open", "high", "low", "close"]
bnb["date"] = pd.to_datetime(bnb["date"], unit="ms")

bnb.head(3)

# 5. Solana: solana
ohlc = cg.get_coin_ohlc_by_id(id="solana", vs_currency="usd", days="365")
solana = pd.DataFrame(ohlc)
solana.columns = ["date", "open", "high", "low", "close"]
solana["date"] = pd.to_datetime(solana["date"], unit="ms")

solana.head(3)

# 6. USDC: usd-coin
ohlc = cg.get_coin_ohlc_by_id(id='usd-coin', vs_currency="usd", days="365")
usdc = pd.DataFrame(ohlc)
usdc.columns = ["date", "open", "high", "low", "close"]
usdc["date"] = pd.to_datetime(usdc["date"], unit="ms")

usdc.head(3)

# 7. XRP: ripple
ohlc = cg.get_coin_ohlc_by_id(id='ripple', vs_currency="usd", days="365")
ripple = pd.DataFrame(ohlc)
ripple.columns = ["date", "open", "high", "low", "close"]
ripple["date"] = pd.to_datetime(ripple["date"], unit="ms")

ripple.head(3)

# 8. Dogecoin: dogecoin
ohlc = cg.get_coin_ohlc_by_id(id='dogecoin', vs_currency="usd", days="365")
doge = pd.DataFrame(ohlc)
doge.columns = ["date", "open", "high", "low", "close"]
doge["date"] = pd.to_datetime(doge["date"], unit="ms")

doge.head(3)

# 9. Toncoin: the-open-network
ohlc = cg.get_coin_ohlc_by_id(id='the-open-network', vs_currency="usd", days="365")
toncoin = pd.DataFrame(ohlc)
toncoin.columns = ["date", "open", "high", "low", "close"]
toncoin["date"] = pd.to_datetime(toncoin["date"], unit="ms")

toncoin.head(3)

# 10. Cardano: cardano
ohlc = cg.get_coin_ohlc_by_id(id='cardano', vs_currency="usd", days="365")
cardano = pd.DataFrame(ohlc)
cardano.columns = ["date", "open", "high", "low", "close"]
cardano["date"] = pd.to_datetime(cardano["date"], unit="ms")

cardano.head(3)

plt.figure(figsize = (10,8))

plt.xlabel('Date')
plt.ylabel('USD')
plt.title('Prices of top 10 cryptocurrencies')

plt.plot(btc['date'], btc['low'])
plt.plot(eth['date'], eth['low'])
plt.plot(tether['date'], tether['low'])
plt.plot(bnb['date'], bnb['low'])
plt.plot(solana['date'], solana['low'])
plt.plot(usdc['date'], usdc['low'])
plt.plot(ripple['date'], ripple['low'])
plt.plot(doge['date'], doge['low'])
plt.plot(toncoin['date'], toncoin['low'])
plt.plot(cardano['date'], cardano['low'])

plt.legend(['BTC', 'ETH', 'Tether', 'BNB', 'Solana', 'USDC', 'XRP', 'Doge', 'Toncoin', 'Cardano'], prop = {"size":8}, loc=0, frameon=True)

plt.show()

crypto_df = pd.concat([btc['date'], btc['low'], eth['low'], tether['low'], bnb['low'], solana['low'],
                        usdc['low'], ripple['low'], doge['low'], toncoin['low'], cardano['low']],
                        axis=1)

crypto_df.columns = ['date', 'BTC', 'ETH', 'Tether', 'BNB', 'Solana', 'USDC', 'XRP', 'Doge', 'Toncoin', 'Cardano']

crypto_df
# using the low price as the main variables for our analysis

crypto_corr = crypto_df.iloc[:,1:].corr()

plt.figure(figsize=(8, 6))
sns.heatmap(crypto_corr, annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Correlation Heatmap for cryptocurrencies')
plt.show()

"""#### NFT data"""

nft_df = pd.read_excel('nft price.xlsx')
nft_df['date'] = pd.to_datetime(nft_df["date"], unit="ms")
nft_df

nft_df.columns

plt.plot(nft_df['date'], nft_df['CryptoPunks'])
plt.plot(nft_df['date'], nft_df['Bored Ape'])
plt.plot(nft_df['date'], nft_df['Pudgy Penguins'])
plt.plot(nft_df['date'], nft_df['Mutant Ape'])
plt.plot(nft_df['date'], nft_df['Azuki'])

plt.xlabel('Date')
plt.ylabel('USD')
plt.title('Prices of NFT collections')

plt.legend(['Cryptopunks', 'Bored Ape', 'Pudgy Penguins', 'Mutant Ape', 'Azuki'])

plt.show()

nft_corr = nft_df.iloc[:,1:].corr()

plt.figure(figsize=(8, 6))
sns.set(font_scale=0.7)
sns.heatmap(nft_corr, annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Correlation Heatmap for NFT')
plt.show()

"""## Modeling - NFT vs Crypto

#### CryptoPunks
"""

cryptopunks = pd.merge(nft_df[['date', 'CryptoPunks']], crypto_df, on='date', how='inner')
cryptopunks

figure, axis = plt.subplots(5, 2, figsize=(10,13))

for i in range(5):
  axis[i,0].scatter(cryptopunks.iloc[:, i*2+2], cryptopunks['CryptoPunks'])
  axis[i,1].scatter(cryptopunks.iloc[:,i*2+3], cryptopunks['CryptoPunks'])

# 0: 2,3
# 1: 4,5

X = cryptopunks.iloc[:,2:]
y = cryptopunks['CryptoPunks']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
reg_cryptopunk = sm.OLS(y_train, X_train).fit()
reg_cryptopunk.summary()

reg_cryptopunk.rsquared_adj

np.sqrt(mean_squared_error(reg_cryptopunk.predict(X_test), y_test))

plt.figure(figsize=(8, 6))
sns.set(font_scale=0.7)
sns.heatmap(cryptopunks.iloc[:,1:].corr(), annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Correlation Heatmap for NFT')
plt.show()

"""#### Bored Ape"""

bored_ape = pd.merge(nft_df[['date', 'Bored Ape']], crypto_df, on='date', how='inner')
bored_ape

X = bored_ape.iloc[:,2:]
y = bored_ape.iloc[:,1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
reg_bored_ape = sm.OLS(y_train, X_train).fit()
reg_bored_ape.summary()

reg_bored_ape.rsquared_adj

np.sqrt(mean_squared_error(reg_bored_ape.predict(X_test), y_test))

"""#### Pudgy Penguins"""

penguin = pd.merge(nft_df[['date', 'Pudgy Penguins']], crypto_df, on='date', how='inner')
penguin

X = penguin.iloc[:,2:]
y = penguin.iloc[:,1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
reg_penguin = sm.OLS(y_train, X_train).fit()
reg_penguin.summary()

reg_penguin.rsquared_adj

np.sqrt(mean_squared_error(reg_penguin.predict(X_test), y_test))

"""#### Mutant Ape"""

mutant_ape = pd.merge(nft_df[['date', 'Mutant Ape']], crypto_df, on='date', how='inner')
mutant_ape

X = mutant_ape.iloc[:,2:]
y = mutant_ape.iloc[:,1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
reg_mutant_ape = sm.OLS(y_train, X_train).fit()
reg_mutant_ape.summary()

reg_mutant_ape.rsquared_adj

np.sqrt(mean_squared_error(reg_mutant_ape.predict(X_test), y_test))

"""#### Azuki"""

azuki = pd.merge(nft_df[['date', 'Azuki']], crypto_df, on='date', how='inner')
azuki

X = azuki.iloc[:,2:]
y = azuki.iloc[:,1]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
reg_azuki = sm.OLS(y_train, X_train).fit()
reg_azuki.summary()

reg_azuki.rsquared_adj

np.sqrt(mean_squared_error(reg_azuki.predict(X_test), y_test))

combined_df = pd.merge(nft_df, crypto_df, on='date', how='inner')
combined_df

plt.figure(figsize=(10, 10))
sns.set(font_scale=0.7)
sns.heatmap(combined_df.iloc[:,1:].corr(), annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Correlation Heatmap')
plt.show()

"""#### Average Prices from both markets"""

combined_df['nft_avg'] = (combined_df['Mutant Ape'] + combined_df['Azuki'] + combined_df['CryptoPunks'] + combined_df['Bored Ape'] +
                          combined_df['Pudgy Penguins']) / 5
combined_df['crypto_avg'] = (combined_df['BTC'] + combined_df['ETH'] + combined_df['Tether'] + combined_df['BNB'] +
                             combined_df['Solana'] + combined_df['USDC'] + combined_df['XRP'] + combined_df['Doge'] +
                             combined_df['Toncoin'] + combined_df['Cardano']) / 10

combined_df

plt.scatter(combined_df['crypto_avg'], combined_df['nft_avg'])

plt.show()

slope = stats.linregress(combined_df['crypto_avg'], combined_df['nft_avg'])[0]
intercept = stats.linregress(combined_df['crypto_avg'], combined_df['nft_avg'])[1]

r_squared = stats.linregress(combined_df['crypto_avg'], combined_df['nft_avg'])[2] ** 2
r_squared

p_val = stats.linregress(combined_df['crypto_avg'], combined_df['nft_avg'])[3]
p_val

def abline(slope, intercept):
     axes = plt.gca()
     x_vals = np.array(axes.get_xlim())
     y_vals = intercept + slope * x_vals
     plt.plot(x_vals, y_vals, '--')

plt.scatter(combined_df['crypto_avg'], combined_df['nft_avg'])
abline(slope, intercept)

plt.xlabel('Average Cryptocurrency Price')
plt.ylabel('Average NFT Price')
plt.title('Cryptocurrency Price vs NFT Price')

plt.show()

"""## Modeling - Forecast for NFT

#### CryptoPunks
"""

punk_value = nft_df['CryptoPunks'].values

adfuller(nft_df['CryptoPunks'].values)

train_size = int(len(nft_df) * 0.8)
cryptopunk_train = punk_value[:train_size]
cryptopunk_test = punk_value[train_size:]

import warnings
warnings.filterwarnings('ignore')

params = list(product(range(0,5,1), range(0,2,1), range(0,5,1)))

aic_list = defaultdict(float)

for p, d, q in params:
  try:
    model = sm.tsa.SARIMAX(cryptopunk_train, order = (p,d,q)).fit()
    aic = model.aic
    aic_list[(p,1,q)] = aic
  except:
    continue

aic_list

sorted(aic_list.items(), key = lambda x:x[1])

arima_punk = sm.tsa.SARIMAX(cryptopunk_train, order = (3,1,3)).fit()
punk_pred = arima_punk.get_prediction(98,122).predicted_mean